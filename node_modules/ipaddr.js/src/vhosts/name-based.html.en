 user has the proper databases
installed and configured.

Features set in this way using the Module::Build object will be
available for querying during the build/test process and after
installation via the generated C<...::ConfigData> module, as
C<< ...::ConfigData->feature($name) >>.

The C<feature()> and C<config_data()> methods represent
Module::Build's main support for configuration of installed modules.
See also L<Module::Build::Authoring/"SAVING CONFIGURATION INFORMATION">.

=item fix_shebang_line(@files)

[version 0.??]

Modify any "shebang" line in the specified files to use the path to the
perl executable being used for the current build.  Files are modified
in-place.  The existing shebang line must have a command that contains
"C<perl>"; arguments to the command do not count.  In particular, this
means that the use of C<#!/usr/bin/env perl> will not be changed.

For an explanation of shebang lines, see
L<http://en.wikipedia.org/wiki/Shebang_%28Unix%29>.

=item have_c_compiler()

[version 0.21]

Returns true if the current system seems to have a working C compiler.
We currently determine this by attempting to compile a simple C source
file and reporting whether the attempt was successful.

=item install_base_relpaths()

=item install_base_relpaths($type)

=item install_base_relpaths($type => $path)

[version 0.28]

Set or retrieve the relative paths that are appended to
C<install_base> for any installable element. This is useful if you
want to set the relative install path for custom build elements.

With no argument, it returns a reference to a hash containing all
elements and their respective values. This hash should not be modified
directly; use the multiple argument below form to change values.

The single argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
C<$value> must be a relative path using Unix-like paths.  (A series of
directories separated by slashes, e.g. C<foo/bar>.)  The return value is a
localized path based on C<$value>.

Assigning the value C<undef> to an element causes it to be removed.

=item install_destination($type)

[version 0.28]

Returns the directory in which items of type C<$type> (e.g. C<lib>,
C<arch>, C<bin>, or anything else returned by the L</install_types()>
method) will be installed during the C<install> action.  Any settings
for C<install_path>, C<install_base>, and C<prefix> are taken into
account when determining the return value.

=item install_path()

=item install_path($type)

=item install_path($type => $path)

[version 0.28]

Set or retrieve paths for specific installable elements. This is
useful when you want to examine any explicit install paths specified
by the user on the command line, or if you want to set the install
path for a specific installable element based on another attribute
like C<install_base()>.

With no argument, it returns a reference to a hash containing all
elements and their respective values. This hash should not be modified
directly; use the multiple argument below form to change values.

The single argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
The supplied C<$path> should be an absolute path to install elements
of C<$type>.  The return value is C<$path>.

Assigning the value C<undef> to an element causes it to be removed.

=item install_types()

[version 0.28]

Returns a list of installable types that this build knows about.
These types each correspond to the name of a directory in F<blib/>,
and the list usually includes items such as C<lib>, C<arch>, C<bin>,
C<script>, C<libdoc>, C<bindoc>, and if HTML documentation is to be
built, C<libhtml> and C<binhtml>.  Other user-defined types may also
exist.

=item invoked_action()

[version 0.28]

This is the name of the original action invoked by the user.  This
value is set when the user invokes F<Build.PL>, the F<Build> script,
or programmatically through the L<dispatch()|/"dispatch($action, %args)">
method.  It does not change as sub-actions are executed as
dependencies are evaluated.

To get the name of the currently executing dependency, see
L</current_action()> above.

=item notes()

=item notes($key)

=item notes($key => $value)

[version 0.20]

The C<notes()> value allows you to store your own persistent
information about the build, and to share that information among
different entities involved in the build.  See the example in the
C<current()> method.

The C<notes()> method is essentially a glorified hash access.  With no
arguments, C<notes()> returns the entire hash of notes.  With one argument,
C<notes($key)> returns the value associated with the given key.  With two
arguments, C<notes($key, $value)> sets the value associated with the given key
to C<$value> and returns the new value.

The lifetime of the C<notes> data is for "a build" - that is, the
C<notes> hash is created when C<perl Build.PL> is run (or when the
C<new()> method is run, if the Module::Build Perl API is being used
instead of called from a shell), and lasts until C<perl Build.PL> is
run again or the C<clean> action is run.

=item orig_dir()

[version 0.28]

Returns a string containing the working directory that was in effect
before the F<Build> script chdir()-ed into the C<base_dir>.  This
might be useful for writing wrapper tools that might need to chdir()
back out.

=item os_type()

[version 0.04]

If you're subclassing Module::Build and some code needs to alter its
behavior based on the current platform, you may only need to know
whether you're running on Windows, Unix, MacOS, VMS, etc., and not the
fine-grained value of Perl's C<$^O> variable.  The C<os_type()> method
will return a string like C<Windows>, C<Unix>, C<MacOS>, C<VMS>, or
whatever is appropriate.  If you're running on an unknown platform, it
will return C<undef> - there shouldn't be many unknown platforms
though.

=item is_vmsish()

=item is_windowsish()

=item is_unixish()

Convenience functions that return a boolean value indicating whether
this platform behaves respectively like VMS, Windows, or Unix.  For
arbitrary reasons other platforms don't get their own such functions,
at least not yet.


=item prefix_relpaths()

=item prefix_relpaths($installdirs)

=item prefix_relpaths($installdirs, $type)

=item prefix_relpaths($installdirs, $type => $path)

[version 0.28]

Set or retrieve the relative paths that are appended to C<prefix> for
any installable element.  This is useful if you want to set the
relative install path for custom build elements.

With no argument, it returns a reference to a hash containing all
elements and their respective values as defined by the current
C<installdirs> setting.

With a single argument, it returns a reference to a hash containing
all elements and their respective values as defined by
C<$installdirs>.

The hash returned by the above calls should not be modified directly;
use the three-argument below form to change values.

The two argument form returns the value associated with the
element C<$type>.

The multiple argument form allows you to set the paths for element types.
C<$value> must be a relative path using Unix-like paths.  (A series of
directories separated by slashes, e.g. C<foo/bar>.)  The return value is a
localized path based on C<$value>.

Assigning the value C<undef> to an element causes it to be removed.

=item get_metadata()

[version 0.36]

This method returns a hash reference of metadata that can be used to create a
YAML datastream. It is provided for authors to override or customize the fields
of F<META.yml>.   E.g.

  package My::Builder;
  use base 'Module::Build';

  sub get_metadata {
    my $self, @args = @_;
    my $data = $self->SUPER::get_metadata(@args);
    $data->{custom_field} = 'foo';
    return $data;
  }

Valid arguments include:

=over

=item *

C<fatal> -- indicates whether missing required
metadata fields should be a fatal error or not.  For META creation, it
generally should, but for MYMETA creation for end-users, it should not be
fatal.

=item *

C<auto> -- indicates whether any necessary configure_requires should be
automatically added.  This is used in META creation.

=back

This method is a wrapper around the old prepare_metadata API now that we
no longer use YAML::Node to hold metadata.

=item prepare_metadata() [deprecated]

[version 0.36]

[Deprecated] As of 0.36, authors should use C<get_metadata> instead.  This
method is preserved for backwards compatibility only.

It takes three positional arguments: a hashref (to which metadata will be
added), an optional arrayref (to which metadata keys will be added in order if
the arrayref exists), and a hashref of arguments (as provided to get_metadata).
The latter argument is new as of 0.36.  Earlier versions are always fatal on
errors.

Prior to version 0.36, this method took a YAML::Node as an argument to hold
assembled metadata.

=item prereq_failures()

[version 0.11]

Returns a data structure containing information about any failed
prerequisites (of any of the types described above), or C<undef> if
all prerequisites are met.

The data structure returned is a hash reference.  The top level keys
are the type of prerequisite failed, one of "requires",
"build_requires", "conflicts", or "recommends".  The associated values
are hash references whose keys are the names of required (or
conflicting) modules.  The associated values of those are hash
references indicating some information about the failure.  For example:

  {
   have => '0.42',
   need => '0.59',
   message => 'Version 0.42 is installed, but we need version 0.59',
  }

or

  {
   have => '<none>',
   need => '0.59',
   message => 'Prerequisite Foo isn't installed',
  }

This hash has the same structure as the hash returned by the
C<check_installed_status()> method, except that in the case of
"conflicts" dependencies we change the "need" key to "conflicts" and
construct a proper message.

Examples:

  # Check a required dependency on Foo::Bar
  if ( $build->prereq_failures->{requires}{Foo::Bar} ) { ...

  # Check whether there were any failures
  if ( $build->prereq_failures ) { ...

  # Show messages for all failures
  my $failures = $build->prereq_failures;
  while (my ($type, $list) = each %$failures) {
    while (my ($name, $hash) = each %$list) {
      print "Failure for $name: $hash->{message}\n";
    }
  }

=item prereq_data()

[version 0.32]

Returns a reference to a hash describing all prerequisites.  The keys of the
hash will be the various prerequisite types ('requires', 'build_requires',
'configure_requires', 'recommends', or 'conflicts') and the values will be
references to hashes of module names and version numbers.  Only prerequisites
types that are defined will be included.  The C<prereq_data> action is just a
thin wrapper around the C<prereq_data()> method and dumps the hash as a string
that can be loaded using C<eval()>.

=item prereq_report()

[version 0.28]

Returns a human-readable (table-form) string showing all
prerequisites, the versions required, and the versions actually
installed.  This can be useful for reviewing the configuration of your
system prior to a build, or when compiling data to send for a bug
report.  The C<prereq_report> action is just a thin wrapper around the
C<prereq_report()> method.

=item prompt($message, $default)

[version 0.12]

Asks the user a question and returns their response as a string.  The
first argument specifies the message to display to the user (for
example, C<"Where do you keep your money?">).  The second argument,
which is optional, specifies a default answer (for example,
C<"wallet">).  The user will be asked the question once.

If C<prompt()> detects that it is not running interactively and there
is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable
is set to true, the $default will be used without prompting.

To prevent automated processes from blocking, the user must either set
PERL_MM_USE_DEFAULT or attach something to STDIN (this can be a
pipe/file containing a scripted set of answers or /dev/null.)

If no $default is provided an empty string will be used instead.  In
non-interactive mode, the absence of $default is an error (though
explicitly passing C<undef()> as the default is valid as of 0.27.)

This method may be called as a class or object method.

=item recommends()

[version 0.21]

Returns a hash reference indicating the C<recommends> prerequisites
that were passed to the C<new()> method.

=item requires()

[version 0.21]

Returns a hash reference indicating the C<requires> prerequisites that
were passed to the C<new()> method.

=item rscan_dir($dir, $pattern)

[version 0.28]

Uses C<File::Find> to traverse the directory C<$dir>, returning a
reference to an array of entries matching C<$pattern>.  C<$pattern>
may either be a regular expression (using C<qr//> or just a plain
string), or a reference to a subroutine that will return true for
wanted entries.  If C<$pattern> is not given, all entries will be
returned.

Examples:

 # All the *.pm files in lib/
 $m->rscan_dir('lib', qr/\.pm$/)

 # All the files in blib/ that aren't *.html files
 $m->rscan_dir('blib', sub {-f $_ and not /\.html$/});

 # All the files in t/
 $m->rscan_dir('t');

=item runtime_params()

=item runtime_params($key)

[version 0.28]

The C<runtime_params()> method stores the values passed on the command line
for valid properties (that is, any command line options for which
C<valid_property()> returns a true value).  The value on the command line may
override the default value for a property, as well as any value specified in a
call to C<new()>.  This allows you to programmatically tell if C<perl Build.PL>
or any execution of C<./Build> had command line options specified that
override valid properties.

The C<runtime_params()> method is essentially a glorified read-only hash.  With
no arguments, C<runtime_params()> returns the entire hash of properties
specified on the command line.  With one argument, C<runtime_params($key)>
returns the value associated with the given key.

The lifetime of the C<runtime_params> data is for "a build" - that is, the
C<runtime_params> hash is created when C<perl Build.PL> is run (or when the
C<new()> method is called, if the Module::Build Perl API is being used instead
of called from a shell), and lasts until C<perl Build.PL> is run again or the
C<clean> action is run.

=item script_files()

[version 0.18]

Returns a hash reference whose keys are the perl script files to be
installed, if any.  This corresponds to the C<script_files> parameter to the
C<new()> method.  With an optional argument, this parameter may be set
dynamically.

For backward compatibility, the C<scripts()> method does exactly the
same thing as C<script_files()>.  C<scripts()> is deprecated, but it
will stay around for several versions to give people time to
transition.

=item up_to_date($source_file, $derived_file)

=item up_to_date(\@source_files, \@derived_files)

[version 0.20]

This method can be used to compare a set of source files to a set of
derived files.  If any of the source files are newer than any of the
derived files, it returns false.  Additionally, if any of the derived
files do not exist, it returns false.  Otherwise it returns true.

The arguments may be either a scalar or an array reference of file
names.

=item y_n($message, $default)

[version 0.12]

Asks the user a yes/no question using C<prompt()> and returns true or
false accordingly.  The user will be asked the question repeatedly
until they give an answer that looks like "yes" or "no".

The first argument specifies the message to display to the user (for
example, C<"Shall I invest your money for you?">), and the second
argument specifies the default answer (for example, C<"y">).

Note that the default is specified as a string like C<"y"> or C<"n">,
and the return value is a Perl boolean value like 1 or 0.  I thought
about this for a while and this seemed like the most useful way to do
it.

This method may be called as a class or object method.

=back


=head2 Autogenerated Accessors

In addition to the aforementioned methods, there are also some get/set
accessor methods for the following properties:

=over 4

=item PL_files()

=item allow_mb_mismatch()

=item auto_configure_requires()

=item autosplit()

=item base_dir()

=item bindoc_dirs()

=item blib()

=item build_bat()

=item build_class()

=item build_elements()

=item build_requires()

=item build_script()

=item bundle_inc()

=item bundle_inc_preload()

=item c_source()

=item config_dir()

=item configure_requires()

=item conflicts()

=item cpan_client()

=item create_license()

=item create_makefile_pl()

=item create_packlist()