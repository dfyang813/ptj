         => \$DBD::Pg::err,
			'Errstr'      => \$DBD::Pg::errstr,
			'State'       => \$DBD::Pg::sqlstate,
			'Attribution' => "DBD::Pg $VERSION by Greg Sabino Mullane and others",
		});


		DBD::Pg::db->install_method('pg_cancel');
		DBD::Pg::db->install_method('pg_endcopy');
		DBD::Pg::db->install_method('pg_getline');
		DBD::Pg::db->install_method('pg_getcopydata');
		DBD::Pg::db->install_method('pg_getcopydata_async');
		DBD::Pg::db->install_method('pg_notifies');
		DBD::Pg::db->install_method('pg_putcopydata');
		DBD::Pg::db->install_method('pg_putcopyend');
		DBD::Pg::db->install_method('pg_ping');
		DBD::Pg::db->install_method('pg_putline');
		DBD::Pg::db->install_method('pg_ready');
		DBD::Pg::db->install_method('pg_release');
		DBD::Pg::db->install_method('pg_result'); ## NOT duplicated below!
		DBD::Pg::db->install_method('pg_rollback_to');
		DBD::Pg::db->install_method('pg_savepoint');
		DBD::Pg::db->install_method('pg_server_trace');
		DBD::Pg::db->install_method('pg_server_untrace');
		DBD::Pg::db->install_method('pg_type_info');

		DBD::Pg::st->install_method('pg_cancel');
		DBD::Pg::st->install_method('pg_result');
		DBD::Pg::st->install_method('pg_ready');

		DBD::Pg::db->install_method('pg_lo_creat');
		DBD::Pg::db->install_method('pg_lo_open');
		DBD::Pg::db->install_method('pg_lo_write');
		DBD::Pg::db->install_method('pg_lo_read');
		DBD::Pg::db->install_method('pg_lo_lseek');
		DBD::Pg::db->install_method('pg_lo_tell');
		DBD::Pg::db->install_method('pg_lo_close');
		DBD::Pg::db->install_method('pg_lo_unlink');
		DBD::Pg::db->install_method('pg_lo_import');
		DBD::Pg::db->install_method('pg_lo_import_with_oid');
		DBD::Pg::db->install_method('pg_lo_export');

		return $drh;

	} ## end of driver


	1;

} ## end of package DBD::Pg


{
	package DBD::Pg::dr;

	use strict;

	## Returns an array of formatted database names from the pg_database table
	sub data_sources {

		my $drh = shift;
		my $attr = shift || '';
		## Future: connect to "postgres" when the minimum version we support is 8.0
		my $connstring = 'dbname=template1';
		if ($ENV{DBI_DSN}) {
			($connstring = $ENV{DBI_DSN}) =~ s/dbi:Pg://i;
		}
		if (length $attr) {
			$connstring .= ";$attr";
		}

		my $dbh = DBD::Pg::dr::connect($drh, $connstring) or return;
		$dbh->{AutoCommit}=1;
		my $SQL = 'SELECT pg_catalog.quote_ident(datname) FROM pg_catalog.pg_database ORDER BY 1';
		my $sth = $dbh->prepare($SQL);
		$sth->execute() or die $DBI::errstr;
		$attr and $attr = ";$attr";
		my @sources = map { "dbi:Pg:dbname=$_->[0]$attr" } @{$sth->fetchall_arrayref()};
		$dbh->disconnect;
		return @sources;
	}


	sub connect { ## no critic (ProhibitBuiltinHomonyms)
		my ($drh, $dbname, $user, $pass, $attr) = @_;

		## Allow "db" and "database" as synonyms for "dbname"
		$dbname =~ s/\b(?:db|database)\s*=/dbname=/;

		my $name = $dbname;
		if ($dbname =~ m{dbname\s*=\s*[\"\']([^\"\']+)}) {
			$name = "'$1'";
			$dbname =~ s/\"/\'/g;
		}
		elsif ($dbname =~ m{dbname\s*=\s*([^;]+)}) {
			$name = $1;
		}

 		$user = defined($user) ? $user : defined $ENV{DBI_USER} ? $ENV{DBI_USER} : '';
		$pass = defined($pass) ? $pass : defined $ENV{DBI_PASS} ? $ENV{DBI_PASS} : '';

		my ($dbh) = DBI::_new_dbh($drh, {
			'Name'         => $dbname,
			'Username'     => $user,
			'CURRENT_USER' => $user,
		 });

		# Connect to the database..
		DBD::Pg::db::_login($dbh, $dbname, $user, $pass, $attr) or return undef;

		my $version = $dbh->{pg_server_version};
		$dbh->{private_dbdpg}{version} = $version;

		if ($attr) {
			if ($attr->{dbd_verbose}) {
				$dbh->trace('DBD');
			}
		}

		return $dbh;
	}

	sub private_attribute_info {
		return {
		};
	}

} ## end of package DBD::Pg::dr


{
	package DBD::Pg::db;

	use DBI qw(:sql_types);

	use strict;

	sub parse_trace_flag {
		my ($h, $flag) = @_;
		return DBD::Pg->parse_trace_flag($flag);
	}

	sub prepare {
		my($dbh, $statement, @attribs) = @_;

		return undef if ! defined $statement;

		# Create a 'blank' statement handle:
		my $sth = DBI::_new_sth($dbh, {
			'Statement' => $statement,
		});

		DBD::Pg::st::_prepare($sth, $statement, @attribs) || 0;

		return $sth;
	}

	sub last_insert_id {

		my ($dbh, $catalog, $schema, $table, $col, $attr) = @_;

		## Our ultimate goal is to get a sequence
		my ($sth, $count, $SQL, $sequence);

		## Cache all of our table lookups? Default is yes
		my $cache = 1;

		## Catalog and col are not used
		$schema = '' if ! defined $schema;
		$table = '' if ! defined $table;
		my $cachename = "lii$table$schema";

		if (defined $attr and length $attr) {
			## If not a hash, assume it is a sequence name
			if (! ref $attr) {
				$attr = {sequence => $attr};
			}
			elsif (ref $attr ne 'HASH') {
				$dbh->set_err(1, 'last_insert_id must be passed a hashref as the final argument');
				return undef;
			}
			## Named sequence overrides any table or schema settings
			if (exists $attr->{sequence} and length $attr->{sequence}) {
				$sequence = $attr->{sequence};
			}
			if (exists $attr->{pg_cache}) {
				$cache = $attr->{pg_cache};
			}
		}

		if (! defined $sequence and exists $dbh->{private_dbdpg}{$cachename} and $cache) {
			$sequence = $dbh->{private_dbdpg}{$cachename};
		}
		elsif (! defined $sequence) {
			## At this point, we must have a valid table name
			if (! length $table) {
				$dbh->set_err(1, 'last_insert_id needs at least a sequence or table name');
				return undef;
			}
			my @args = ($table);
			## Make sure the table in question exists and grab its oid
			my ($schemajoin,$schemawhere) = ('','');
			if (length $schema) {
				$schemajoin = "\n JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)";
				$schemawhere = "\n AND n.nspname = ?";
				push @args, $schema;
			}
			$SQL = "SELECT c.oid FROM pg_catalog.pg_class c $schemajoin\n WHERE relname = ?$schemawhere";
			if (! length $schema) {
				$SQL .= ' AND pg_catalog.pg_table_is_visible(c.oid)';
			}
			$sth = $dbh->prepare_cached($SQL);
			$count = $sth->execute(@args);
			if (!defined $count or $count eq '0E0') {
				$sth->finish();
				my $message = qq{Could not find the table "$table"};
				length $schema and $message .= qq{ in the schema "$schema"};
				$dbh->set_err(1, $message);
				return undef;
			}
			my $oid = $sth->fetchall_arrayref()->[0][0];
			$oid =~ /(\d+)/ or die qq{OID was not numeric?!?\n};
			$oid = $1;
			## This table has a primary key. Is there a sequence associated with it via a unique, indexed column?
			$SQL = "SELECT a.attname, i.indisprimary, pg_catalog.pg_get_expr(adbin,adrelid)\n".
				"FROM pg_catalog.pg_index i, pg_catalog.pg_attribute a, pg_catalog.pg_attrdef d\n ".
				"WHERE i.indrelid = $oid AND d.adrelid=a.attrelid AND d.adnum=a.attnum\n".
				"  AND a.attrelid = $oid AND i.indisunique IS TRUE\n".
				"  AND a.atthasdef IS TRUE AND i.indkey[0]=a.attnum\n".
				q{ AND d.adsrc ~ '^nextval'};
			$sth = $dbh->prepare($SQL);
			$count = $sth->execute();
			if (!defined $count or $count eq '0E0') {
				$sth->finish();
				$dbh->set_err(1, qq{No suitable column found for last_insert_id of table "$table"});
				return undef;
			}
			my $info = $sth->fetchall_arrayref();

			## We have at least one with a default value. See if we can determine sequences
			my @def;
			for (@$info) {
				next unless $_->[2] =~ /^nextval\(+'([^']+)'::/o;
				push @$_, $1;
				push @def, $_;
			}
			if (!@def) {
				$dbh->set_err(1, qq{No suitable column found for last_insert_id of table "$table"\n});
			}
			## Tiebreaker goes to the primary keys
			if (@def > 1) {
				my @pri = grep { $_->[1] } @def;
				if (1 != @pri) {
					$dbh->set_err(1, qq{No suitable column found for last_insert_id of table "$table"\n});
				}
				@def = @pri;
			}
			$sequence = $def[0]->[3];
			## Cache this information for subsequent calls
			$dbh->{private_dbdpg}{$cachename} = $sequence;
		}

		$sth = $dbh->prepare_cached('SELECT currval(?)');
		$count = $sth->execute($sequence);
		return undef if ! defined $count;
		return $sth->fetchall_arrayref()->[0][0];

	} ## end of last_insert_id

	sub ping {
		my $dbh = shift;
		local $SIG{__WARN__} = sub { } if $dbh->FETCH('PrintError');
		my $ret = DBD::Pg::db::_ping($dbh);
		return $ret < 1 ? 0 : $ret;
	}

	sub pg_ping {
		my $dbh = shift;
		local $SIG{__WARN__} = sub { } if $dbh->FETCH('PrintError');
		return DBD::Pg::db::_ping($dbh);
	}

	sub pg_type_info {
		my($dbh,$pg_type) = @_;
		local $SIG{__WARN__} = sub { } if $dbh->FETCH('PrintError');
		my $ret = DBD::Pg::db::_pg_type_info($pg_type);
		return $ret;
	}

	# Column expected in statement handle returned.
	# table_cat, table_schem, table_name, column_name, data_type, type_name,
 	# column_size, buffer_length, DECIMAL_DIGITS, NUM_PREC_RADIX, NULLABLE,
	# REMARKS, COLUMN_DEF, SQL_DATA_TYPE, SQL_DATETIME_SUB, CHAR_OCTET_LENGTH,
	# ORDINAL_POSITION, IS_NULLABLE
	# The result set is ordered by TABLE_SCHEM, TABLE_NAME and ORDINAL_POSITION.

	sub column_info {
		my $dbh = shift;
		my ($catalog, $schema, $table, $column) = @_;

		my @search;
		## If the schema or table has an underscore or a %, use a LIKE comparison
		if (defined $schema and length $schema) {
			push @search, 'n.nspname ' . ($schema =~ /[_%]/ ? 'LIKE ' : '= ') .
				$dbh->quote($schema);
		}
		if (defined $table and length $table) {
			push @search, 'c.relname ' . ($table =~ /[_%]/ ? 'LIKE ' : '= ') .
				$dbh->quote($table);
		}
		if (defined $column and length $column) {
			push @search, 'a.attname ' . ($column =~ /[_%]/ ? 'LIKE ' : '= ') .
				$dbh->quote($column);
		}

		my $whereclause = join "\n\t\t\t\tAND ", '', @search;

		my $schemajoin = 'JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)';

		my $remarks = 'pg_catalog.col_description(a.attrelid, a.attnum)';

		my $column_def = $dbh->{private_dbdpg}{version} >= 80000
			? 'pg_catalog.pg_get_expr(af.adbin, af.adrelid)'
			: 'af.adsrc';

		my $col_info_sql = qq!
            SELECT
                NULL::text AS "TABLE_CAT"
                , quote_ident(n.nspname) AS "TABLE_SCHEM"
                , quote_ident(c.relname) AS "TABLE_NAME"
                , quote_ident(a.attname) AS "COLUMN_NAME"
                , a.atttypid AS "DATA_TYPE"
                , pg_catalog.format_type(a.atttypid, NULL) AS "TYPE_NAME"
                , a.attlen AS "COLUMN_SIZE"
                , NULL::text AS "BUFFER_LENGTH"
                , NULL::text AS "DECIMAL_DIGITS"
                , NULL::text AS "NUM_PREC_RADIX"
                , CASE a.attnotnull WHEN 't' THEN 0 ELSE 1 END AS "NULLABLE"
                , $remarks AS "REMARKS"
                , $column_def AS "COLUMN_DEF"
                , NULL::text AS "SQL_DATA_TYPE"
                , NULL::text AS "SQL_DATETIME_SUB"
                , NULL::text AS "CHAR_OCTET_LENGTH"
                , a.attnum AS "ORDINAL_POSITION"
                , CASE a.attnotnull WHEN 't' THEN 'NO' ELSE 'YES' END AS "IS_NULLABLE"
                , pg_catalog.format_type(a.atttypid, a.atttypmod) AS "pg_type"
                , '?' AS "pg_constraint"
                , n.nspname AS "pg_schema"
                , c.relname AS "pg_table"
                , a.attname AS "pg_column"
                , a.attrelid AS "pg_attrelid"
                , a.attnum AS "pg_attnum"
                , a.atttypmod AS "pg_atttypmod"
                , t.typtype AS "_pg_type_typtype"
                , t.oid AS "_pg_type_oid"
            FROM
                pg_catalog.pg_type t
                JOIN pg_catalog.pg_attribute a ON (t.oid = a.attt