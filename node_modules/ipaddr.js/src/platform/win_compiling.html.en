o replace the old with the new.  Instead, here you
can in-place edit:

    foreach my $item_r ($h->content_refs_list) {
        next if ref $$item_r;
        $$item_r =~ s/honour/honor/g;
    }

You I<could> currently achieve the same affect with:

    foreach my $item (@{ $h->content_array_ref }) {
        # deprecated!
        next if ref $item;
        $item =~ s/honour/honor/g;
    }

...except that using the return value of C<< $h->content >> or
C<< $h->content_array_ref >> to do that is deprecated, and just might stop
working in the future.

=head2 implicit

  $is_implicit = $h->implicit();
  $h->implicit($make_implicit);

Returns (optionally sets) the "_implicit" attribute.  This attribute is
a flag that's used for indicating that the element was not originally
present in the source, but was added to the parse tree (by
HTML::TreeBuilder, for example) in order to conform to the rules of
HTML structure.

=head2 pos

  $pos = $h->pos();
  $h->pos($element);

Returns (and optionally sets) the "_pos" (for "current I<pos>ition")
pointer of C<$h>.  This attribute is a pointer used during some
parsing operations, whose value is whatever HTML::Element element
at or under C<$h> is currently "open", where C<< $h->insert_element(NEW) >>
will actually insert a new element.

(This has nothing to do with the Perl function called C<pos>, for
controlling where regular expression matching starts.)

If you set C<< $h->pos($element) >>, be sure that C<$element> is
either C<$h>, or an element under C<$h>.

If you've been modifying the tree under C<$h> and are no longer
sure C<< $h->pos >> is valid, you can enforce validity with:

    $h->pos(undef) unless $h->pos->is_inside($h);

=head2 all_attr

  %attr = $h->all_attr();

Returns all this element's attributes and values, as key-value pairs.
This will include any "internal" attributes (i.e., ones not present
in the original element, and which will not be represented if/when you
call C<< $h->as_HTML >>).  Internal attributes are distinguished by the fact
that the first character of their key (not value! key!) is an
underscore ("_").

Example output of C<< $h->all_attr() >> :
C<'_parent', >I<[object_value]>C< , '_tag', 'em', 'lang', 'en-US',
'_content', >I<[array-ref value]>.

=head2 all_attr_names

  @names = $h->all_attr_names();
  $num_attrs = $h->all_attr_names();

Like C<all_attr>, but only returns the names of the attributes.
In scalar context, returns the number of attributes.

Example output of C<< $h->all_attr_names() >> :
C<'_parent', '_tag', 'lang', '_content', >.

=head2 all_external_attr

  %attr = $h->all_external_attr();

Like C<all_attr>, except that internal attributes are not present.

=head2 all_external_attr_names

  @names = $h->all_external_attr_names();
  $num_attrs = $h->all_external_attr_names();

Like C<all_attr_names>, except that internal attributes' names
are not present (or counted).

=head2 id

  $id = $h->id();
  $h->id($string);

Returns (optionally sets to C<$string>) the "id" attribute.
C<< $h->id(undef) >> deletes the "id" attribute.

C<< $h->id(...) >> is basically equivalent to C<< $h->attr('id', ...) >>,
except that when setting the attribute, this method returns the new value,
not the old value.

=head2 idf

  $id = $h->idf();
  $h->idf($string);

Just like the C<id> method, except that if you call C<< $h->idf() >> and
no "id" attribute is defined for this element, then it's set to a
likely-to-be-unique value, and returned.  (The "f" is for "force".)

=head1 STRUCTURE-MODIFYING METHODS

These methods are provided for modifying the content of trees
by adding or changing nodes as parents or children of other nodes.

=head2 push_content

  $h->push_content($element_or_text, ...);

Adds the specified items to the I<end> of the content list of the
element C<$h>.  The items of content to be added should each be either a
text segment (a string), an HTML::Element object, or an arrayref.
Arrayrefs are fed thru C<< $h->new_from_lol(that_arrayref) >> to
convert them into elements, before being added to the content
list of C<$h>.  This means you can say things concise things like:

  $body->push_content(
    ['br'],
    ['ul',
      map ['li', $_], qw(Peaches Apples Pears Mangos)
    ]
  );

See the L</new_from_lol> method's documentation, far below, for more
explanation.

Returns C<$h> (the element itself).

The push_content method will try to consolidate adjacent text segments
while adding to the content list.  That's to say, if C<$h>'s C<content_list> is

  ('foo bar ', $some_node, 'baz!')

and you call

   $h->push_content('quack?');

then the resulting content list will be this:

  ('foo bar ', $some_node, 'baz!quack?')

and not this:

  ('foo bar ', $some_node, 'baz!', 'quack?')

If that latter is what you want, you'll have to override the
feature of consolidating text by using splice_content,
as in:

  $h->splice_content(scalar($h->content_list),0,'quack?');

Similarly, if you wanted to add 'Skronk' to the beginning of
the content list, calling this:

   $h->unshift_content('Skronk');

then the resulting content list will be this:

  ('Skronkfoo bar ', $some_node, 'baz!')

and not this:

  ('Skronk', 'foo bar ', $some_node, 'baz!')

What you'd to do get the latter is:

  $h->splice_content(0,0,'Skronk');

=head2 unshift_content

  $h->unshift_content($element_or_text, ...)

Just like C<push_content>, but adds to the I<beginning> of the C<$h>
element's content list.

The items of content to be added should each be
either a text segment (a string), an HTML::Element object, or
an arrayref (which is fed thru C<new_from_lol>).

The unshift_content method will try to consolidate adjacent text segments
while adding to the content list.  See above for a discussion of this.

Returns C<$h> (the element itself).

=head2 splice_content

  @removed = $h->splice_content($offset, $length,
                                $element_or_text, ...);

Detaches the elements from C<$h>'s list of content-nodes, starting at
C<$offset> and continuing for C<$length> items, replacing them with the
elements of the following list, if any.  Returns the elements (if any)
removed from the content-list.  If C<$offset> is negative, then it starts
that far from the end of the array, just like Perl's normal C<splice>
function.  If C<$length> and the following list is omitted, removes
everything from C<$offset> onward.

The items of content to be added (if any) should each be either a text
segment (a string), an arrayref (which is fed thru L</new_from_lol>),
or an HTML::Element object that's not already
a child of C<$h>.

=head2 detach

  $old_parent = $h->detach();

This unlinks C<$h> from its parent, by setting its 'parent' attribute to
undef, and by removing it from the content list of its parent (if it
had one).  The return value is the parent that was detached from (or
undef, if C<$h> had no parent to start with).  Note that neither C<$h> nor
its parent are explicitly destroyed.

=head2 detach_content

  @old_content = $h->detach_content();

This unlinks all of C<$h>'s children from C<$h>, and returns them.
Note that these are not explicitly destroyed; for that, you
can just use C<< $h->delete_content >>.

=head2 replace_with

  $h->replace_with( $element_or_text, ... )

This replaces C<$h> in its parent's content list with the nodes
specified.  The element C<$h> (which by then may have no parent)
is returned.  This causes a fatal error if C<$h> has no parent.
The list of nodes to insert may contain C<$h>, but at most once.
Aside from that possible exception, the nodes to insert should not
already be children of C<$h>'s parent.

Also, note that this method does not destroy C<$h> if weak references are
turned off -- use C<< $h->replace_with(...)->delete >> if you need that.

=head2 preinsert

  $h->preinsert($element_or_text...);

Inserts the given nodes right BEFORE C<$h> in C<$h>'s parent's
content list.  This causes a fatal error if C<$h> has no parent.
None of the given nodes should be C<$h> or other children of C<$h>.
Returns C<$h>.

=head2 postinsert

  $h->postinsert($element_or_text...)

Inserts the given nodes right AFTER C<$h> in C<$h>'s parent's content
list.  This causes a fatal error if C<$h> has no parent.  None of
the given nodes should be C<$h> or other children of C<$h>.  Returns
C<$h>.

=head2 replace_with_content

  $h->replace_with_content();

This replaces C<$h> in its parent's content list with its own content.
The element C<$h> (which by then has no parent or content of its own) is
returned.  This causes a fatal error if C<$h> has no parent.  Also, note
that this does not destroy C<$h> if weak references are turned off -- use
C<< $h->replace_with_content->delete >> if you need that.

=head2 delete_content

  $h->delete_content();
  $h->destroy_content(); # alias

Clears the content of C<$h>, calling C<< $h->delete >> for each content
element.  Compare with C<< $h->detach_content >>.

Returns C<$h>.

C<destroy_content> is an alias for this method.

=head2 delete

  $h->delete();
  $h->destroy(); # alias

Detaches this element from its parent (if it has one) and explicitly
destroys the element and all its descendants.  The return value is
the empty list (or C<undef> in scalar context).

Before version 5.00 of HTML::Element, you had to call C<delete> when
you were finished with the tree, or your program would leak memory.
This is no longer necessary if weak references are enabled, see
L</"Weak References">.

=head2 destroy

An alias for L</delete>.

=head2 destroy_content

An alias for L</delete_content>.

=head2 clone

  $copy = $h->clone();

Returns a copy of the element (whose children are clones (recursively)
of the original's children, if any).

The returned element is parentless.  Any '_pos' attributes present in the
source element/tree will be absent in the copy.  For that and other reasons,
the clone of an HTML::TreeBuilder object that's in mid-parse (i.e, the head
of a tree that HTML::TreeBuilder is elaborating) cannot (currently) be used
to continue the parse.

You are free to clone HTML::TreeBuilder trees, just as long as:
1) they're done being parsed, or 2) you don't expect to resume parsing
into the clone.  (You can continue parsing into the original; it is
never affected.)

=head2 clone_list

  @copies = HTML::Element->clone_list(...nodes...);

Returns a list consisting of a copy of each node given.
Text segments are simply copied; elements are cloned by
calling C<< $it->clone >> on each of them.

Note that this must be called as a class method, not as an instance
method.  C<clone_list> will croak if called as an instance method.
You can also call it like so:

    ref($h)->clone_list(...nodes...)

=head2 normalize_content

  $h->normalize_content

Normalizes the content of C<$h> -- i.e., concatenates any adjacent
text nodes.  (Any undefined text segments are turned into empty-strings.)
Note that this does not recurse into C<$h>'s descendants.

=head2 delete_ignorable_whitespace

  $h->delete_ignorable_whitespace()

This traverses under C<$h> and deletes any text segments that are ignorable
whitespace.  You should not use this if C<$h> is under a C<< <pre> >> element.

=head2 insert_element

  $h->insert_element($element, $implicit);

Inserts (via push_content) a new element under the element at
C<< $h->pos() >>.  Then updates C<< $h->pos() >> to point to the inserted
element, unless $element is a prototypically empty element like
C<< <br> >>, C<< <hr> >>, C<< <img> >>, etc.
The new C<< $h->pos() >> is returned.  This
method is useful only if your particular tree task involves setting
C<< $h->pos() >>.

=head1 DUMPING METHODS

=head2 dump

  $h->dump()
  $h->dump(*FH)  ; # or *FH{IO} or $fh_obj

Prints the element and all its children to STDOUT (or to a specified
filehandle), in a format useful
only for debugging.  The structure of the document is shown by
indentation (no end tags).

=head2 as_HTML

  $s = $h->as_HTML();
  $s = $h->as_HTML($entities);
  $s = $h->as_HTML($entities, $indent_char);
  $s = $h->as_HTML($entities, $indent_char, \%optional_end_tags);

Returns a string representing in HTML the element and its
descendants.  The optional argument C<$entities> specifies a string of
the entities to encode.  For compatibility with previous versions,
specify C<'E<lt>E<gt>&'> here.  If omitted or undef, I<all> unsafe
characters are encoded as HTML entities.  See L<HTML::Entities> for
details.  If passed an empty string, no entities are encoded.

If $indent_char is specified and defined, the HTML to be output is
intented, using the string you specify (which you probably should
set to "\t", or some number of spaces, if you specify it).

If C<\%optional_end_tags> is specified and defined, it should be
a reference to a hash that holds a true value for every tag name
whose end tag is optional.  Defaults to
C<\%HTML::Element::optionalEndTag>, which is an alias to
C<%HTML::Tagset::optionalEndTag>, which, at time of writing, contains
true values for C<p, li, dt, dd>.  A useful value to pass is an empty
hashref, C<{}>, which means that no end-tags are optional for this dump.
Otherwise, possibly consider copying C<%HTML::Tagset::optionalEndTag> to a
hash of your own, adding or deleting values as you like, and passing
a reference to that hash.

=head2 as_text

  $s = $h->as_text();
  $s = $h->as_text(skip_dels => 1);

Returns a string consisting of only the text parts of the element's
descendants.  Any whitespace inside the element is included unchanged,
but whitespace not in the tree is never added.  But remember that
whitespace may be ignored or compacted by HTML::TreeBuilder during
parsing (depending on the value of the C<ignore_ignorable_whitespace>
and C<no_space_compacting> attributes).  Also, since whitespace is
never added during parsing,

  HTML::TreeBuilder->new_from_content("<p>a</p><p>b</p>")
                   ->as_text;

returns C<"ab">, not C<"a b"> or C<"a\nb">.

Text under C<< <script> >> or C<< <style> >> elements is never
included in what's returned.  If C<skip_dels> is true, then text
content under C<< <del> >> nodes is not included in what's returned.

=head2 as_trimmed_text

  $s = $h->as_trimmed_text(...);
  $s = $h->as_trimmed_text(extra_chars => '\xA0'); # remove &nbsp;
  $s = $h->as_text_trimmed(...); # alias

This is just like C<as_text(...)> except that leading and trailing
whitespace is deleted, and any internal whitespace is collapsed.

This will not remove non-breaking spaces, Unicode spaces, or any other
non-ASCII whitespace unless you supply the extra characters as
a string argument (e.g. C<< $h->as_trimmed_text(extra_chars => '\xA0') >>).
C<extra_chars> may be any string that can appear inside a character
class, including ranges like C<a-z>, POSIX character classes like
C<[:alpha:]>, and character class escapes like C<\p{Zs}>.

=head2 as_XML

  $s = $h->as_XML()

Returns a string representing in XML the element and its descendants.

The XML is not indented.

=head2 as_Lisp_form

  $s = $h->as_Lisp_form();

Returns a string representing the element and its descendants as a
Lisp form.  Unsafe characters are encoded as octal escapes.

The Lisp form is indented, and contains external ("href", etc.)  as
well as internal attributes ("_tag", "_content", "_implicit", etc.),
except for "_parent", which is omitted.

Current example output for a given element:

  ("_tag" "img" "border" "0" "src" "pie.png" "usemap" "#main.map")

=head2 format

  $s = $h->format; # use HTML::FormatText
  $s = $h->format($formatter);

Formats text output. Defaults to HTML::FormatText.

Takes a second argument that is a reference to a formatter.

=head2 starttag

  $start = $h->starttag();
  $start = $h->starttag($entities);

Returns a string representing the complete start tag for the element.
I.e., leading "<", tag name, attributes, and trailing ">".
All values are surrounded with
double-quotes, and appropriate characters are encoded.  If C<$entities>
is omitted or undef, I<all> unsafe characters are encoded as HTML
entities.  See L<HTML::Entities> for details.  If you specify some
value for C<$entities>, remember to include the double-quote character in
it.  (Previous versions of this module would basically behave as if
C<'&"E<gt>'> were specified for C<$entities>.)  If C<$entities> is
an empty string, no entity is escaped.

=head2 starttag_XML

  $start = $h->starttag_XML();

Returns a string representing the complete start tag for the element.

=head2 endtag

  $end = $h->endtag();

Returns a string representing the complete end tag for this element.
I.e., "</", tag name, and ">".

=head2 endtag_XML

  $end = $h->endtag_XML();

Returns a string representing the complete end tag for this element.
I.e., "</", tag name, and ">".

=head1 SECONDARY STRUCTURAL METHODS

These methods all involve some structural aspect of the tree;
either they report some aspect of the tree's structure, or they involve
traversal down the tree, or walking up the tree.

=head2 is_inside

  $inside = $h->is_inside('tag', $element, ...);

Returns true if the C<$h> element is, or is contained anywhere inside an
element that is any of the ones listed, or whose tag name is any of
the tag names listed.  You can use any mix of elements and tag names.

=head2 is_empty

  $empty = $h->is_empty();

Returns true if C<$h> has no content, i.e., has no elements or text
segments under it.  In other words, this returns true if C<$h> is a leaf
node, AKA a terminal node.  Do not confuse this sense of "empty" with
another sense that it can have in SGML/HTML/XML terminology, which
means that the element in question is of the type (like HTML's C<< <hr> >>,
C<< <br> >>, C<< <img> >>, etc.) that I<can't> have any content.

That is, a particular C<< <p> >> element may happen to have no content, so
$that_p_element->is_empty will be true -- even though the prototypical
C<< <p> >> element isn't "empty" (not in the way that the prototypical
C<< <hr> >> element is).

If you think this might make for potentially confusing code, consider
simply using the clearer exact equivalent:  C<< not($h->content_list) >>.

=head2 pindex

  $index = $h->pindex();

Return the index of the element in its parent's contents array, such
that C<$h> would equal

  $h->parent->content->[$h->pindex]
  # or
  ($h->parent->content_list)[$h->pindex]

assuming C<$h> isn't root.  If the element C<$h> is root, then
C<< $h->pindex >> returns C<undef>.

=head2 left

  $element = $h->left();
  @elements = $h->left();

In scalar context: returns the node that's the immediate left sibling
of C<$h>.  If C<$h> is the leftmost (or only) child of its parent (or has no
parent), then this returns undef.

In list context: returns all the nodes that're the left siblings of C<$h>
(starting with the leftmost).  If C<$h> is the leftmost (or only) child
of its parent (or has no parent), then this returns an empty list.

(See also C<< $h->preinsert(LIST) >>.)

=head2 right

  $element = $h->right();
  @elements = $h->right();

In scalar context: returns the node that's the immediate right sibling
of C<$h>.  If C<$h> is the rightmost (or only) child of its parent (or has
no parent), then this returns C<undef>.

In list context: returns all the nodes that're the right siblings of
C<$h>, starting with the leftmost.  If C<$h> is the rightmost (or only) child
of its parent (or has no parent), then this returns an empty list.

(See also C<< $h->postinsert(LIST) >>.)

=head2 address

  $address = $h->address();
  $element_or_text = $h->address($address);

The first form (with no parameter) returns a string representing the
location of C<$h> in the tree it is a member of.
The address consists of numbers joined by a '.', starting with '0',
and followed by the pindexes of the nodes in the tree that are
ancestors of C<$h>, starting from the top.

So if the way to get to a node starting at the root is to go to child
2 of the root, then child 10 of that, and then child 0 of that, and
then you're there -- then that node's address is "0.2.10.0".

As a bit of a special case, the address of the root is simply "0".

I forsee this being used mainly for debugging, but you may
find your own uses for it.

  $element_or_text = $h->address($address);

This form returns the node (whether element or text-segment) at
the given address in the tree that C<$h> is a part of.  (That is,
the address is resolved starting from C<< $h->root >>.)

If there is no node at the given address, this returns C<undef>.

You can specify "relative addressing" (i.e., that indexing is supposed
to start from C<$h> and not from C<< $h->root >>) by having the address start
with a period -- e.g., C<< $h->address(".3.2") >> will look at child 3 of C<$h>,
and child 2 of that.

=head2 depth

  $depth = $h->depth();

Returns a number expressing C<$h>'s depth within its tree, i.e., how many
steps away it is from the root.  If C<$h> has no parent (i.e., is root),
its depth is 0.

=head2 root

  $root = $h->root();

Returns the element that's the top of C<$h>'s tree.  If C<$h> is
root, this just returns C<$h>.  (If you want to test whether C<$h>
I<is> the root, instead of asking what its root is, just test
C<< not($h->parent) >>.)

=head2 lineage

  @lineage = $h->lineage();

Returns the list of C<$h>'s ancestors, starting with its parent,
and then that parent's parent, and so on, up to the root.  If C<$h>
is root, this returns an empty list.

If you simply want a count of the number of elements in C<$h>'s lineage,
use C<< $h->depth >>.

=head2 lineage_tag_names

  @names = $h->lineage_tag_names();

Returns the list of the tag names of C<$h>'s ancestors, starting
with its parent, and that parent's parent, and so on, up to the
root.  If C<$h> is root, this returns an empty list.
Example output: C<('em', 'td', 'tr', 'table', 'body', 'html')>

Equivalent to:

  map { $_->tag } $h->lineage;

=head2 descendants

  @descendants = $h->descendants();

In list context, returns the list of all C<$h>'s descendant elements,
listed in pre-order (i.e., an element appears before its
content-elements).  Text segments DO NOT appear in the list.
In scalar context, returns a count of all such elements.

=head2 descendents

This is just an alias to the C<descendants> method, for people who
can't spell.

=head2 find_by_tag_name

  @elements = $h->find_by_tag_name('tag', ...);
  $first_match = $h->find_by_tag_name('tag', ...);

In list context, returns a list of elements at or under C<$h> that have
any of the specified tag names.  In scalar context, returns the first
(in pre-order traversal of the tree) such element found, or undef if
none.

=head2 find

This is just an alias to C<find_by_tag_name>.  (There was once
going to be a whole find_* family of methods, but then C<look_down>
filled that niche, so there turned out not to be much reason for the
verboseness of the name "find_by_tag_name".)

=head2 find_by_attribute

  @elements = $h->find_by_attribute('attribute', 'value');
  $first_match = $h->find_by_attribute('attribute', 'value');

In a list context, returns a list of elements at or under C<$h> that have
the specified attribute, and have the given value for that attribute.
In a scalar context, returns the first (in pre-order traversal of the
tree) such element found, or undef if none.

This method is B<deprecated> in favor of the more expressive
C<look_down> method, which new code should use instead.

=head2 look_down

  @elements = $h->look_down( ...criteria... );
  $first_match = $h->look_down( ...criteria... );

This starts at C<$h> and looks thru its element descendants (in
pre-order), looking for elements matching the criteria you specify.
In list context, returns all elements that match all the given
criteria; in scalar context, returns the first such element (or undef,
if nothing matched).

There are three kinds of criteria you can specify:

=over

=item (attr_name, attr_value)

This means you're looking for an element with that value for that
attribute.  Example: C<"alt", "pix!">.  Consider that you can search
on internal attribute values too: C<"_tag", "p">.

=item (attr_name, qr/.../)

This means you're looking for an element whose value for that
attribute matches the specified Regexp object.

=item a coderef

This means you're looking for elements where coderef->(each_element)
returns true.  Example:

  my @wide_pix_images = $h->look_down(
    _tag => "img",
    alt  => "pix!",
    sub { $_[0]->attr('width') > 350 }
  );

=back

Note that C<(attr_name, attr_value)> and C<(attr_name, qr/.../)>
criteria are almost always faster than coderef
criteria, so should presumably be put before them in your list of
criteria.  That is, in the example above, the sub ref is called only
for elements that have already passed the criteria of having a "_tag"
attribute with value "img", and an "alt" attribute with value "pix!".
If the coderef were first, it would be called on every element, and
I<then> what elements pass that criterion (i.e., elements for which
the coderef returned true) would be checked for their "_tag" and "alt"
attributes.

Note that comparison of string attribute-values against the string
value in C<(attr_name, attr_value)> is case-INsensitive!  A criterion
of C<('align', 'right')> I<will> match an element whose "align" value
is "RIGHT", or "right" or "rIGhT", etc.

Note also that C<look_down> considers "" (empty-string) and undef to
be different things, in attribute values.  So this:

  $h->look_down("alt", "")

will find elements I<with> an "alt" attribute, but where the value for
the "alt" attribute is "".  But this:

  $h->look_down("alt", undef)

is the same as:

  $h->look_down(sub { !defined($_[0]->attr('alt')) } )

That is, it finds elements that do not have an "alt" attribute at all
(or that do have an "alt" attribute, but with a value of undef --
which is not normally possible).

Note that when you give several criteria, this is taken to mean you're
looking for elements that match I<all> your criterion, not just I<any>
of them.  In other words, there is an implicit "and", not an "or".  So
if you wanted to express that you wanted to find elements with a
"name" attribute with the value "foo" I<or> with an "id" attribute
with the value "baz", you'd have to do it like:

  @them = $h->look_down(
    sub {
      # the lcs are to fold case
      lc($_[0]->attr('name')) eq 'foo'
      or lc($_[0]->attr('id')) eq 'baz'
    }
  );

Coderef criteria are more expressive than C<(attr_name, attr_value)>
and C<(attr_name, qr/.../)>
criteria, and all C<(attr_name, attr_value)>
and C<(attr_name, qr/.../)>
criteria could be
expressed in terms of coderefs.  However, C<(attr_name, attr_value)>
and C<(attr_name, qr/.../)>
criteria are a convenient shorthand.  (In fact, C<look_down> itself is
basically "shorthand" too, since anything you can do with C<look_down>
you could do by traversing the tree, either with the C<traverse>
method or with a routine of your own.  However, C<look_down> often
makes for very concise and clear code.)

=head2 look_up

  @elements = $h->look_up( ...criteria